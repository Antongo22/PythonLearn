# Функции
# Функции — это блок кода, который может быть вызван из других функций.
# Функции могут принимать аргументы и возвращать значения. Могут и не принимать

# для того, чтобы определить функцию, необходимо использовать ключевое слово def и дальше в скобках передать парметры
def my_func(name):
    print(f"Hello, {name}!")

# Эта функция ничего не возвращяет, а просто приветсвует пользователя

# Вызов функции
my_func("World")
my_func("Python")

# Однако, функции могут возвращять значения
def get_name():
    name = input("Введите имя: ")
    return name

name = get_name()
print(f"Hello, {name}!")
# Тут в функции мы получаем имя пользователя и возвращяем его

# Можно и совместить!
def get_sum(a, b):
    print(a + b)
    return a + b

sum = get_sum(10, 20)
# Тут функция и выводит результат и возвращяет его

# В функции можно вызывать другие функции
def get_name():
    return input("Введите имя: ")

def get_age():
    return input("Введите возраст: ")

def show_info():
    return f"Hello, {get_name()}! You are {get_age()} years old."

print(show_info())

# В функции можно вызывать саму себя!
def sum(a, b):
    print(a, b)
    if a > 100:
        return a + b
    else:
        return sum(a + 1, b)

print(sum(1, 2))

# Тут мы прибавляем к первому числу второе, пока оно не станет больше 100

# Очень важно продумывать выход из функции, иначе будет ошибка переполнения памяти

# Аргументы по умолчанию
# Функции могут иметь аргументы по умолчанию, которые используются, если при вызове функции соответствующие аргументы не были переданы.
def power(base, exponent=2):
    return base ** exponent

print(power(3))     # Возвращает 9, так как exponent по умолчанию равен 2
print(power(3, 3))  # Возвращает 27

# Именованные и позиционные аргументы
# При вызове функции можно использовать именованные аргументы для явного указания значений параметров.
# Это улучшает читаемость кода и позволяет указывать аргументы в произвольном порядке.

def profile(name, age, city):
    print(f"Name: {name}, Age: {age}, City: {city}")

profile(age=25, name="Bob", city="New York")


# Переменное количество аргументов
# Функции могут принимать переменное количество аргументов с помощью *args и **kwargs.
# *args используется для передачи произвольного количества позиционных аргументов в виде кортежа.
def print_numbers(*args):
    for number in args:
        print(number)

print_numbers(1, 2, 3, 4, 5)


# **kwargs используется для передачи произвольного количества именованных аргументов в виде словаря.
def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="Alice", age=30, city="Paris")

# Лямбда-функции
square = lambda x: x ** 2 # Пишется ключевое слово lambda, после параметры функции, а затем выражение
print(square(4))  # Вывод: 16
# Лямбда-функции — это небольшие анонимные функции, которые определяются с помощью ключевого слова lambda.
# Они обычно используются для коротких функций, которые не требуют имени.


# Вложенные функции
# Функции могут быть определены внутри других функций. Вложенные функции имеют доступ к переменным внешних функций.
def outer_function(x):
    def inner_function(y):
        return y * y
    return inner_function(x) + 1

print(outer_function(3))  # Вывод: 10


# Функции как объекты
# Функции в Python являются объектами первого класса, что означает,
# что их можно передавать как аргументы другим функциям, возвращать из функций и присваивать переменным.
def add(a, b):
    return a + b

def apply_function(func, x, y):
    return func(x, y)

result = apply_function(add, 5, 3)  # result будет равен 8


# Декораторы
# Декораторы — это функции, которые модифицируют поведение других функций.
# Они часто используются для добавления функциональности, такой как логирование или проверка прав доступа.
def decorator_function(original_function):
    def wrapper_function(*args, **kwargs):
        print("Wrapper executed")
        return original_function(*args, **kwargs)
    return wrapper_function

@decorator_function
def display():
    return "Display function executed"

print(display())  # Вывод: Wrapper executed \n Display function executed

# Ууу, сложна! Но, давай разберём как оно работает
def decorator_function(func):
    def wrapper_function():
        print("До вызова функции")
        func()
        print("После вызова функции")
    return wrapper_function

def function_to_be_used():
    print("Эта функция будет вызвана")

function_to_be_used = decorator_function(function_to_be_used)

function_to_be_used() # До вызова функции \n Эта функция будет вызвана \n После вызова функции

# Тут мы просто как аргумент функции передаём другую функцию, да, так можно!
# Но, возникает проблема, если мы хотим, чтобы функция вызывала другую функцию,
# то придётся функцию-декоратор каждый раз настраивать плд вызываемую функцию, а это не вариант!
# Для решения этой проблемы мы передаём *args, **kwargs как аргументы декоратора, для того,
# чтобы наш декоратор был универсальным


def decorator_function1(func):
    def wrapper_function(*args, **kwargs):
        print("До вызова функции")
        func(*args, **kwargs)
        print("После вызова функции")
    return wrapper_function

def function_to_be_used1(title):
    print(title)

function_to_be_used = decorator_function1(function_to_be_used1)

function_to_be_used("Text") # До вызова функции \n Text \n После вызова функции

# Уже лучше! Но, что если функция будет что-то возвращять
def decorator_function2(func):
    def wrapper_function(*args, **kwargs):
        print("До вызова функции")
        answer = func(*args, **kwargs)
        print("После вызова функции")
        return answer
    return wrapper_function

def function_to_be_used2(title):
    print("Вызвано")
    return "Hello " + title

function_to_be_used = decorator_function1(function_to_be_used2)

print(function_to_be_used("Text")) # До вызова функции \n Вызвано \n После вызова функции \n Hello Text

# Отлично! Но, чтобы было удобнее, мы напишем так -

def decorator_function3(func):
    def wrapper_function(*args, **kwargs):
        print("До вызова функции")
        answer = func(*args, **kwargs)
        print("После вызова функции")
        return answer
    return wrapper_function

@decorator_function3
def function_to_be_used3(title):
    print("Вызвано")
    return "Hello " + title


print(function_to_be_used3("Text")) # До вызова функции \n Вызвано \n После вызова функции \n Hello Text

# По сути - то же самое, просто удобнее


# так же можно возвращать несколько параметров

def return_tuple(a, b):
    return b, a

a, b = return_tuple(1, 2)
print(a, b)

# Функции в Python — это основной инструмент для организации кода, улучшения его читаемости и
# повторного использования. Они позволяют абстрагировать логику и выполнять операции с аргументами,
# возвращая результаты. Функции могут быть простыми или сложными, поддерживать переменное количество аргументов
# и работать как объекты первого класса, что делает их мощным инструментом в вашем арсенале программиста.


# Функции

# Задача 1: Приветствие пользователя
# Напишите функцию greet_user(name), которая принимает имя пользователя и выводит приветственное сообщение.


# Задача 2: Функция для вычисления площади прямоугольника
# Напишите функцию, которая принимает длину и ширину прямоугольника и возвращает его площадь.


# Задача 3: Функция для вычисления факториала числа
# Напишите функцию, которая принимает число и возвращает его факториал.


# Задача 4: Функция для проверки четности числа
# Напишите функцию, которая принимает число и возвращает True, если оно четное, и False в противном случае.


# Задача 5: Функция для вывода строки заданное количество раз
# Напишите функцию, которая принимает строку и число, и выводит строку на экран это число раз.


# Задача 6: Функция для нахождения максимального элемента в списке
# Напишите функцию, которая принимает список чисел и возвращает максимальный элемент в списке.


# Задача 7: Функция для проверки палиндрома
# Напишите функцию, которая принимает строку и возвращает True, если строка является палиндромом, и False в противном случае.


# Задача 8: Функция для подсчета количества гласных в строке
# Напишите функцию, которая принимает строку и возвращает количество гласных букв в этой строке. (vowels в питоне это гласные буквы)


# Задача 9: Функция для перевода градусов Цельсия в Фаренгейты
# Напишите функцию, которая принимает температуру в градусах Цельсия и возвращает температуру в градусах Фаренгейта.


# Задача 10: Функция для генерации списка квадратов чисел
# Напишите функцию, которая принимает число n и возвращает список квадратов чисел от 1 до n.




# Задача 1
# Напишите функцию, которая принимает два числа и возвращает их сумму.

# Задача 2
# Напишите функцию, которая принимает строку и выводит ее в верхнем регистре.

# Задача 3
# Напишите функцию, которая принимает список чисел и возвращает их среднее значение. (лямбда)

# Задача 4
# Напишите функцию, которая принимает два числа и возвращает максимальное из них. (лямбда)

# Задача 5
# Напишите функцию, которая проверяет, является ли число четным. (лямбда)

# Задача 6
# Напишите функцию, которая принимает произвольное количество чисел и возвращает их сумму. Используйте *args.

# Задача 7

# Напишите функцию, которая принимает произвольное количество ключевых словарных аргументов и возвращает словарь с этими аргументами.
# Используйте **kwargs.

# Задача 8
# Напишите функцию, которая возвращает квадрат числа. Используйте лямбда-функцию.

# Задача 9
# Напишите рекурсивную функцию для вычисления факториала числа.


# Задача 10
# Напишите функцию-декоратор, которая измеряет время выполнения другой функции и выводит его на экран.

# Задача 11
# Напишите функцию, которая принимает список строк и возвращает только те строки, которые содержат букву "a".

# Задача 12
# Напишите функцию, которая принимает словарь и возвращает список его ключей, отсортированных в алфавитном порядке.

# Задача 13
# Напишите функцию, которая принимает список чисел и возвращает новый список, содержащий только четные числа.
# Используйте фильтрацию с лямбда-функцией.

# Задача 14
# Напишите рекурсивную функцию, которая находит n-й элемент Фибоначчи.

# Задача 15
# Напишите функцию-декоратор, которая логирует вызов функции и ее результат.


