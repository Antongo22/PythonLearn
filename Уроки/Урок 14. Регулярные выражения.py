# Регулярное выражение – это последовательность символов, используемая для поиска и замены текста в строке или файле.

# Для выполнения операций сопоставления с шаблонами регулярных выражений и замены фрагментов строк используется модуль re.
# Модуль поддерживает операции как со строками Юникода, так и со строками байтов.

# Шаблоны регулярных выражений определяются как строки, состоящие из смеси текста и последовательностей специальных символов.
# В шаблонах часто используются специальные символы и символ обратного слэша, поэтому они обычно оформляются, как «сырые» строки, такие как

some_text = r'здесь регулярное выражение'

# Синтаксис шаблонов
# Ниже приводится список основных последовательностей специальных символов, которые используются в шаблонах регулярных выражений:

# .
# Соответствует любому символу, кроме символа перевода строки.
#
# ^
# Соответствует позиции начала строки.
#
# $
# Соответствует позиции конца строки.
#
# *
# Ноль или более повторений предшествующего выражения.
#
# +
# Одно или более повторений предшествующего выражения.
#
# ?
# Ноль или одно повторение предшествующего выражения.
#
# {m}
# Соответствует точно m повторениям предшествующего выражения.
#
# {m, n}
# Соответствует от m до n повторений предшествующего выражения.
#
# {m,}
# От m до бесконечности.
#
# [...]
# Соответствует любому символу, присутствующему в множестве, таком как [abcdef]или [a-zA-z]. Специальные символы, такие как *, утрачивают свое специальное значение внутри множества.
#
# [^...]
# Соответствует любому символу, не присутствующему в множестве, таком как [^0-9].
#
# A|B
# Соответствует либо A, либо B, где A и B являются регулярными выражениями.
#
# (...)
# Подстрока, соответствующая регулярному выражению в круглых скобках, интерпретируется как группа и сохраняется.
# Содержимое группы может быть получено с помо-щью метода group() объектов класса MatchObject,
# которые возвращаются операцией поиска совпадений.
# Стандартные экранированные последовательности, такие как "\n" и "\t", точно так же интерпретируются и в регулярных выражениях
# (например, выражению r"\n+" будет соответствовать один или более символов перевода строки).
# Кроме того, литералы символов, которые в регулярных выражениях имеют специальное значение, можно указывать,
# предваряя их символом обратного слэша. Например, выражению r"\*" соответствует символ *.
# Дополнительно ряд экранированных последовательностей, начинающихся символом обратного слэша, соответствуют специальным символам:

# \число
# Соответствует фрагменту текста, совпавшему с группой с указанным номером. Группы нумеруются от 1 до 99, слева направо.
#
# \A
# Соответствует только началу строки.
# \b
# Соответствует пустой строке в позиции начала или конца слова. Под словом подразумевается последовательность алфавитно-цифровых символов, завершающаяся пробельным или любым другим не алфавитно-цифровым символом.
#
# \B
# Соответствует пустой строке не в позиции начала или конца слова.
#
# \d
# Соответствует любой десятичной цифре. То же, что и выражение [0-9].
#
# \D
# Соответствует любому нецифровому символу. То же, что и выражение [^0-9].
#
# \s
# Соответствует любому пробельному символу. То же, что и выражение [\t\n\r\f\v ].
#
# \S
# Соответствует любому не пробельному символу. То же, что и выражение [^\t\n\r\f\v ].
#
# \w
# Соответствует любому алфавитно-цифровому символу.
#
# \W
# Соответствует любому символу, не относящемуся к множеству \w.
#
# \Z
# Соответствует только концу строки.
#
# \
# Соответствует самому символу обратного слэша.


# Специальные символы \d, \D, \s, \S, \w и \W интерпретируются иначе при сопоставлении со строками Юникода.
# В данном случае они совпадают со всеми символами Юникода, соответствующими описанным свойствам.
# Например, \d совпадает со всеми символами Юникода, которые классифицируются как цифры, будь то европейские,
# арабские или индийские цифры, каждые из которых занимают различные диапазоны символов Юникода.


# Флаги

# A или ASCII
# Сопоставление выполняется только с 8-битными символами ASCII.
#
# I или IGNORECASE
# Сопоставление выполняется без учета регистра символов.
#
# L или LOCALE
# При сопоставлении со специальными символами \w, \W, \b и \B используются региональные настройки.
#
# M или MULTILINE
# Обеспечивает совпадение символов ^ и $ с началом и концом каждой строки в тексте, помимо начала и конца самого текста. (Обычно символы ^ и $ совпадают только с началом и концом всего текста.)
#
# S или DOTALL
# Обеспечивает совпадение символа точки (.) со всеми символами, включая символ перевода строки.
#
# X или VERBOSE
# Игнорирует неэкранированные пробельные символы и комментарии в строке шаблона.




# Методы модуля re
# re.findall(pattern, string, flags=0)
# Возвращает список всех неперекрывающихся совпадений с шаблоном pattern в строке string, включая пустые совпадения.
# Если шаблон имеет группы, возвращает список фрагментов текста, совпавших с группами.
# Если в шаблоне присутствует более одной группы, каждый элемент в списке будет представлен кортежем, содержащим текст из каждой группы.


# re.match(pattern, string, flags=0)
# Проверяет наличие совпадения с шаблоном pattern в строке string.
# В случае успеха возвращает объект типа MatchObject, в противном случае возвращается None.


# re.search(pattern, string, flags=0)
# Отыскивает в строке string первое совпадение с шаблоном pattern.
# В случае успеха возвращает объект типа MatchObject; если совпадений не найдено, возвращается None.

# re.split(pattern, string, maxsplit=0, flags=0)
#Разбивает строку string по совпадениям с шаблоном pattern.
# Возвращает список строк, включая текст, совпавший с группами, присутствующими в шаблоне.
# В аргументе maxsplit передается максимальное количество выполняемых разбиений.
# По умолчанию выполняются все возможные разбиения.

# re.subn(pattern, repl, string, count=0, flag=0)
# Замещает текстом repl самые первые неперекрывающиеся совпадения с шаблоном pattern в строке string.
# В аргументе repl допускается использовать обратные ссылки на группы в шаблоне, такие как \6.
# Аргумент count определяет максимальное количество подстановок. По умолчанию замещаются все найденные совпадения.
# Возвращает кортеж, содержащий новую строку и количество выполненных подстановок.

# re.sub(pattern, repl, string, count=0, flag=0)
# Тоже, что и re.subn, но возвращает изменённую строку.


# re.compile(pattern, flags=0)
# Компилирует регулярное выражение для дальнейшего использования с методами данного регулярного выражения.


# Пример
import re
text = "John will be out of the office from 12/15/2012 - 1/3/2013."

# Шаблон регулярного выражения для поиска дат
datepat = re.compile('(\d+)/(\d+)/(\d+)')

# Найти и вывести все даты
for m in datepat.finditer(text):
    print(m.group())

# Отыскать все даты и вывести их в другом формате
monthnames = [None,'Jan','Feb','Mar','Apr','May','Jun',
                'Jul','Aug','Sep','Oct','Nov','Dec']
for m in datepat.finditer(text):
    s = f' {monthnames[int(m.group(1))]}, {m.group(2)}, {m.group(3)}'
    print(s)

# Заменить все даты их значениями в европейском формате (день/месяц/год)
def fix_date(m):
    return f"{m.group(2)}/{m.group(1)}/{m.group(3)}"
newtext = datepat.subn(fix_date, text)

# Альтернативный способ замены
newtext = datepat.subn(r'\2/\1/\3', text)