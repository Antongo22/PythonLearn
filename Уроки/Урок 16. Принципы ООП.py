# Перейдём к 3 столпам ООП - инкапсуляция, наследование и полиморфизм.
# На самом деле их больше, но это 3 основные, остальные ты поймёшь уже по мере разработки.

# Инкапсуляция
# Ты уже знаешь, что к полям класса можно обращатся. Но так ведь можно поменять что-то нужное и всё сломается.
# Поэтому, есть инкапсуляция - защита от изменения полей и сокрытие из вне.
# Для того, чтобы закрыть доступ к переменной/функции, перед их названием ставятся "__".
# Это модификатор доступа - privat. Ещё есть "_" - это protected, он нужен нам будет, когда мы перейдём к наследованию.
# Давай рассмотрии на примере класса собаки.

class Dog:
    def __init__(self, name, age):
        self.name = name
        self.__age = age

    def __play(self):
        print("Собака играет!")

    def info(self):
        print(f"Имя: {self.name}\nВозраст: {self.__age}")


dog1 = Dog("Rex", 5)
print(dog1.name)
try:
    print(dog1.age)
except:
    print("Нельзя получить доступ, тк доступ скрыт!")

dog1.info()
try:
    dog1.play()
except:
    print("Нельзя получить доступ, тк метод скрыт!")
print()


# Но, внутри класса доступ к своим скрытым полям получить можно.
# Для того, чтобы получить доступ к скрытым полям принято использовать геттеры - для доступа, и сеттеры - для получения.
# Обычно, геттеры и сеттеры пишут с таким же названием, что и переменная, но тут я написал для наглядности преписку "_set" и "_get"
# То есть эти функции будут вызваны при попытке получить или задать данные
class Cat:
    def __init__(self, name, age):
        self.name = name
        self.__age = age

    # Геттер для возраста. Используем как переменную, не нужно писать скобки
    @property
    def age_get(self):
        print("Получен возраст")
        return self.__age

    # Сеттер для возраста, вызывается при попытке изменения параметра. Используем как переменную, не нужно писать скобки
    @age_get.setter  # в начало нужно ставить имя геттера
    def age_set(self, value):
        print("Установлен возраст")
        if value >= 0:  # Проверка на корректность значения
            self.__age = value
        else:
            print("Возраст не может быть отрицательным.")

    def __play(self):
        print("Кошка играет! Метод зыкрыь")

    # внутри класса можно получить доступ к сокрытым функциям
    def play_open(self):
        self.__play()

    def info(self):
        print(f"Имя: {self.name}\nВозраст: {self.__age}")


# Пример использования
cat = Cat("Мурка", 3)
print(cat.age_get)  # Получаем возраст через геттер

cat.age_set = 5  # Устанавливаем новый возраст через сеттер
print(cat.age_get)

cat.age_set = -1  # Попытка установить некорректный возраст

cat.play_open()
print()
print()


# Вот мы и разобрались с инкапсуляцией.
# Перейдём к наследованию. Наследование - это создание нового класса, который наследует свойства другого класса.
# Базовый класс называется родительским, а тот, который его наследует - дочерним.
# Если в базовом классе есть модифакатор privat, то у дочернего класса доступа к этому полю не будет.
# Но, если в базовом есть модификатор protected, то для дочернего доступ будет, а извне нет.
# Посмотрим на примере
class Animal:
    def __init__(self, name, age, weight):
        self.name = name  # доступ есть везде
        self._age = age  # доступ есть в этом классе и в дочерних
        self.__weight = weight  # доступ только в этом классе


class Fish(Animal):
    def __init__(self, name, age, weight, size):
        super().__init__(name, age,
                         weight)  # если у нас есть конструктор в дочернем классе, то нужно вызвать конструктор родительского
        # если конструктора в дочернем классе нет, то берётся конструктор родительского
        self.size = size

    def info(self):
        print(f"Имя: {self.name}\nВозраст: {self._age}\nРазмер: {self.size}")
        # Вес получить нельзя. Он срыт он нас.


animal = Animal("Животное", 2, 0.5)
try:
    print(animal.size)
except:
    print("Такого поля нет у amial, только в Fish!")

fish = Fish("Щука", 2, 0.5, 0.5)
fish.info()
print(fish.size)  # а тут уже есть такое поле
print()
print()


# И от класса рыбы можно унаследовать! Это называется множественным наследованием.
class Carp(Fish):
    def __init__(self, name, age, weight, size, length):
        super().__init__(name, age, weight, size)
        self.length = length

    def info(self):
        print(f"Имя: {self.name}\nВозраст: {self._age}\nРазмер: {self.size}\nДлина: {self.length}")


carp = Carp("Карп", 2, 0.5, 0.5, 0.5)
carp.info()
print()
print()
# Кстати, класс может наследовать сразу несколько классов,
# для этого, в скобочках нужно передать родительские классы через запятую

# С наследованием, надеюсь понятно. Перейдём к последнему и очень страшному слову - полиморфизм.
# Если описать это, то это разная реакция объектов при одном и том же действии.
# То есть это переопредиление методов дочернего класса
# Проще понять на примере
class Person:
    def __init__(self, name):
        self.name = name

    def walk(self):
        print(f"{self.name} ходит")


class Employee(Person):
    def __init__(self, name, salary):
        super().__init__(name)
        self.salary = salary

    def walk(self):
        print(f"{self.name} идёт на работу")

class Student(Person):
    def __init__(self, name, marks):
        super().__init__(name)
        self.marks = marks

    def walk(self):
        print(f"{self.name} идёт на учебу")



person = Person("Вася")
person.walk()
employee = Employee("Петя", 1000)
employee.walk()
student = Student("Коля", 5)
student.walk()

# метод у всех один, а результаты разные. Это и есть полиморфизм, ничего сложного.

# Теперь, давай чуть расширим знания о наследования, добавив абстрактный класс.
# Отличается от тем, что от него нельзя создать экземпляр, и нужен он чисто для наследования
# Для того, чтобы создать абстрактный класс, нужно унаследовать класс от ABC
# Так же, в таких классах можно создать абстрактные методы, которые будут полностью реализованы уже в дочернем классе
from abc import ABC, abstractmethod
class Car(ABC):
    @abstractmethod
    def turn_on(self):
        pass

    @abstractmethod
    def turn_off(self):
        pass

class Lada(Car):
    def turn_on(self):
        print("Лада завелась. Удивительно")

    def turn_off(self):
        print("Лада выключилась.")


# Не забывай это:
# Класс – тип данных описывающий объект
# Объект – тип данных, экземпляр класса
# Метод объекта – сообщение, с помощью которого объекты общаются друг с другом
# Атрибут объекта – хранилище текущего состояния объекта
# Свойство объекта – интерфейс доступа к атрибутам объекта
# Класс – самостоятельный тип. Может иметь свои методы и атрибуты

# Задачи

# Задача 1: Создание простого класса
# Создайте класс `Book`, который имеет следующие атрибуты: название (title), автор (author) и год публикации (year).
# Все поля-приватные.
# Реализуйте метод `info`, который выводит полную информацию о книге.


# Задача 2: Инкапсуляция и геттеры/сеттеры
# Создайте класс `Person`, который имеет атрибуты `name` и `age`.
# Скрыть атрибут `age` и предоставить геттер и сеттер для этого атрибута.
# Реализуйте метод `info`, который выводит информацию о человеке.


# Задача 3: Наследование и метод `super()`
# Создайте класс `Animal` с атрибутами `name` и `species`.
# Создайте класс `Dog`, который наследует от `Animal` и добавляет атрибут `breed`.
# Реализуйте метод `info` в `Dog`, который выводит полную информацию о собаке.


# Задача 4: Полиморфизм и переопределение методов
# Создайте базовый класс `Shape` с методом `area`, который должен быть переопределён в дочерних классах.
# Реализуйте два дочерних класса: `Rectangle` и `Circle`, которые переопределяют метод `area` для вычисления площади.


# Задача 5: Наследование и полиморфизм в методах
# Расширьте задачу 4, добавив метод `describe` в каждый класс, который выводит описание формы.
# Используйте полиморфизм для реализации разных описаний для `Rectangle` и `Circle`.


# Задача 6: Множественное наследование
# Создайте два класса `Engine` и `Vehicle`. Класс `Vehicle` должен наследовать от обоих классов.
# Класс `Engine` имеет метод `start`, а `Vehicle` добавляет атрибут `model` и переопределяет метод `describe`.


# Задача 7: Композиция и агрегация
# Создайте класс `Library`, который содержит список книг (используйте класс `Book` из задачи 1).
# Реализуйте методы для добавления книг и вывода всех книг в библиотеке.



# Задача 8: Виртуальные методы и абстрактные классы
# Используйте модуль `abc` для создания абстрактного класса `Appliance` с абстрактными методами `turn_on` и `turn_off`.
# Реализуйте классы `WashingMachine` и `Refrigerator`, которые наследуют от `Appliance` и реализуют эти методы.


# Задача 9: Декораторы и приватные методы
# Создайте класс `BankAccount` с приватным атрибутом `__balance`. Реализуйте методы для депозита и снятия средств.
# Используйте декораторы для проверки допустимости операций.


# Задача 10: Реализация нескольких интерфейсов
# Создайте интерфейсы `Flyable` и `Swimmable` с методами `fly` и `swim` соответственно.
# Реализуйте класс `Duck`, который реализует оба интерфейса и переопределяет методы `fly` и `swim`.

